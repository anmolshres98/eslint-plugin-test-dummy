diff --git a/dist/rules/no-internal.js b/dist/rules/no-internal.js
index 104333775794c4f5d6d850ded1331efcf4d82653..04bfa093f0d3a143332c4336cc4b54b5b173ca56 100644
--- a/dist/rules/no-internal.js
+++ b/dist/rules/no-internal.js
@@ -168,7 +168,7 @@ module.exports = {
       for (const jsDoc of declaration.jsDoc) {
         if (jsDoc.tags) {
           for (const tag of jsDoc.tags) {
-            if (!bannedTags.includes(tag.tagName.escapedText) || !isCheckedFile(declaration)) {
+            if (!bannedTags.includes(tag.tagName.escapedText)) {
               continue;
             }
             //Violation key to track and report violations on a per-usage basis
@@ -231,6 +231,15 @@ module.exports = {
         const resolvedSymbol = typeChecker.getSymbolAtLocation(tsCall.expression);
         if (resolvedSymbol)
           checkWithParent(resolvedSymbol.valueDeclaration, node);
+
+        if (!tsCall.arguments) return;
+
+        for (const arg of tsCall.arguments) {
+          const argType = typeChecker.getTypeAtLocation(arg);
+          if (argType && argType.symbol) {
+            checkWithParent(argType.symbol.valueDeclaration, node);
+          }
+        }
       },
 
       NewExpression(node) {
@@ -294,13 +303,52 @@ module.exports = {
       },
 
       TSTypeReference(node) {
-        const tsCall = parserServices.esTreeNodeToTSNodeMap.get(node);
-        if (!tsCall)
+        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
+        if (!tsNode) return;
+
+        const resolvedType = typeChecker.getTypeAtLocation(tsNode);
+        if (resolvedType && resolvedType.symbol) {
+          checkWithParent(resolvedType.symbol.valueDeclaration, node);
+        }
+      },
+
+      ClassDeclaration(node) {
+        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
+        if (!tsNode || !tsNode.heritageClauses) return;
+
+        for (const clause of tsNode.heritageClauses) {
+          for (const type of clause.types) {
+            const resolvedType = typeChecker.getTypeAtLocation(type.expression);
+            if (resolvedType && resolvedType.symbol) {
+              checkWithParent(resolvedType.symbol.valueDeclaration, node);
+            }
+          }
+        }
+      },
+
+      BinaryExpression(node) {
+        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
+        if (!tsNode || tsNode.operatorToken.kind !== ts.SyntaxKind.InstanceOfKeyword)
           return;
 
-        const resolved = typeChecker.getTypeAtLocation(tsCall);
-        if (resolved)
-          checkWithParent(resolved.declaration, node);
+        const resolvedType = typeChecker.getTypeAtLocation(tsNode.right);
+        if (resolvedType && resolvedType.symbol) {
+          checkWithParent(resolvedType.symbol.valueDeclaration, node);
+        }
+      },
+
+      ImportDeclaration(node) {
+        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
+        if (!tsNode) return;
+
+        const resolvedModule = typeChecker.getSymbolAtLocation(tsNode.moduleSpecifier);
+        if (resolvedModule && resolvedModule.exports) {
+          resolvedModule.exports.forEach((exportSymbol) => {
+            if (exportSymbol.valueDeclaration) {
+              checkWithParent(exportSymbol.valueDeclaration, node);
+            }
+          });
+        }
       },
     };
   }
