diff --git a/dist/rules/no-internal.js b/dist/rules/no-internal.js
index 104333775794c4f5d6d850ded1331efcf4d82653..0f9322e913961027fbda62c18f44136cd43a2d52 100644
--- a/dist/rules/no-internal.js
+++ b/dist/rules/no-internal.js
@@ -26,6 +26,7 @@ const syntaxKindFriendlyNames = {
   [ts.SyntaxKind.PropertySignature]: "property",
   [ts.SyntaxKind.Constructor]: "constructor",
   [ts.SyntaxKind.EnumMember]: "enum member",
+  [ts.SyntaxKind.VariableDeclaration]: "variable",
 }
 
 /**
@@ -162,42 +163,45 @@ module.exports = {
     }
 
     function checkJsDoc(declaration, node) {
-      if (!declaration || !declaration.jsDoc)
+      if (!declaration)
         return undefined;
 
-      for (const jsDoc of declaration.jsDoc) {
-        if (jsDoc.tags) {
-          for (const tag of jsDoc.tags) {
-            if (!bannedTags.includes(tag.tagName.escapedText) || !isCheckedFile(declaration)) {
-              continue;
-            }
-            //Violation key to track and report violations on a per-usage basis
-            const violationKey = `${declaration.kind}_${declaration.symbol.escapedName}_${tag}_${node.range[0]}`;
-            if (reportedViolationsSet.has(violationKey)) {
-              continue;
-            }
-            reportedViolationsSet.add(violationKey);
-            let name;
-            if (declaration.kind === ts.SyntaxKind.Constructor)
-              name = declaration.parent.symbol.escapedName;
-            else {
-              name = declaration.symbol.escapedName;
-              const parentSymbol = getParentSymbolName(declaration);
-              if (parentSymbol)
-                name = `${parentSymbol}.${name}`;
-            }
+      // Use TypeScript's utility to get JSDoc tags
+      const jsDocTags = ts.getJSDocTags(declaration);
+      if (!jsDocTags || jsDocTags.length === 0) return;
 
-            context.report({
-              node,
-              messageId: "forbidden",
-              data: {
-                kind: syntaxKindFriendlyNames.hasOwnProperty(declaration.kind) ? syntaxKindFriendlyNames[declaration.kind] : "unknown object type " + declaration.kind,
-                name,
-                tag: tag.tagName.escapedText,
-              }
-            });
+      for (const tag of jsDocTags) {
+        if (!bannedTags.includes(tag.tagName.escapedText)) {
+          continue;
+        }
+
+        // Violation key to track and report violations on a per-usage basis
+        const violationKey = `${declaration.kind}_${declaration.symbol?.escapedName}_${tag.tagName.text}_${node.range[0]}`;
+        if (reportedViolationsSet.has(violationKey)) {
+          continue;
+        }
+        reportedViolationsSet.add(violationKey);
+
+        let name;
+        if (declaration.kind === ts.SyntaxKind.Constructor) {
+          name = declaration.parent.symbol.escapedName;
+        } else {
+          name = declaration.symbol?.escapedName;
+          const parentSymbol = getParentSymbolName(declaration);
+          if (parentSymbol) {
+            name = `${parentSymbol}.${name}`;
           }
         }
+
+        context.report({
+          node,
+          messageId: "forbidden",
+          data: {
+            kind: syntaxKindFriendlyNames.hasOwnProperty(declaration.kind) ? syntaxKindFriendlyNames[declaration.kind] : "unknown object type " + declaration.kind,
+            name,
+            tag: tag.tagName.escapedText,
+          }
+        });
       }
     }
 
@@ -231,6 +235,15 @@ module.exports = {
         const resolvedSymbol = typeChecker.getSymbolAtLocation(tsCall.expression);
         if (resolvedSymbol)
           checkWithParent(resolvedSymbol.valueDeclaration, node);
+
+        if (!tsCall.arguments) return;
+
+        for (const arg of tsCall.arguments) {
+          const argType = typeChecker.getTypeAtLocation(arg);
+          if (argType) {
+            checkWithParent(argType.symbol.valueDeclaration, node);
+          }
+        }
       },
 
       NewExpression(node) {
@@ -239,7 +252,7 @@ module.exports = {
           return;
 
         const resolvedClass = typeChecker.getTypeAtLocation(tsCall);
-        if (resolvedClass && resolvedClass.symbol)
+        if (resolvedClass)
           checkWithParent(resolvedClass.symbol.valueDeclaration, node);
 
         const resolvedConstructor = typeChecker.getResolvedSignature(tsCall);
@@ -294,13 +307,64 @@ module.exports = {
       },
 
       TSTypeReference(node) {
-        const tsCall = parserServices.esTreeNodeToTSNodeMap.get(node);
-        if (!tsCall)
+        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
+        if (!tsNode) return;
+
+        const resolvedType = typeChecker.getTypeAtLocation(tsNode);
+        if (resolvedType) {
+          checkWithParent(resolvedType.symbol.valueDeclaration, node);
+        }
+      },
+
+      ClassDeclaration(node) {
+        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
+        if (!tsNode || !tsNode.heritageClauses) return;
+
+        for (const clause of tsNode.heritageClauses) {
+          for (const type of clause.types) {
+            const resolvedType = typeChecker.getTypeAtLocation(type.expression);
+            if (resolvedType) {
+              checkWithParent(resolvedType.symbol.valueDeclaration, node);
+            }
+          }
+        }
+      },
+
+      BinaryExpression(node) {
+        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
+        if (!tsNode || tsNode.operatorToken.kind !== ts.SyntaxKind.InstanceOfKeyword)
           return;
 
-        const resolved = typeChecker.getTypeAtLocation(tsCall);
-        if (resolved)
-          checkWithParent(resolved.declaration, node);
+        const resolvedType = typeChecker.getTypeAtLocation(tsNode.right);
+        if (resolvedType) {
+          checkWithParent(resolvedType.symbol.valueDeclaration, node);
+        }
+      },
+
+      ImportDeclaration(node) {
+        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
+        if (!tsNode) return;
+
+        const resolvedModule = typeChecker.getSymbolAtLocation(tsNode.moduleSpecifier);
+        if (!resolvedModule || !resolvedModule.exports) return;
+
+        if (node.specifiers) {
+          for (const specifier of node.specifiers) {
+            if (specifier.type === "ImportSpecifier" || specifier.type === "ImportDefaultSpecifier" || specifier.type === "ImportNamespaceSpecifier") {
+              let exportSymbol;
+              if (specifier.type === "ImportDefaultSpecifier") {
+                exportSymbol = typeChecker.getAliasedSymbol(resolvedModule.exports.get("default")); 
+              }
+              else {
+                exportSymbol = resolvedModule.exports.get(specifier.imported?.name);
+              }
+
+              if (exportSymbol && exportSymbol.valueDeclaration) {
+                checkWithParent(exportSymbol.valueDeclaration, specifier);
+              }
+            }
+          }
+        }
       },
     };
   }
